package cat.i2cat.mcaslite.management;

import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ExecutionException;
import cat.i2cat.mcaslite.config.dao.DAO;
<<<<<<< HEAD
import cat.i2cat.mcaslite.config.model.ApplicationConfig;
import cat.i2cat.mcaslite.config.model.TranscoRequest;
import cat.i2cat.mcaslite.config.model.TranscoStatus;
=======
import cat.i2cat.mcaslite.config.model.TRequest;
>>>>>>> MCASLive2
import cat.i2cat.mcaslite.exceptions.MCASException;
import cat.i2cat.mcaslite.utils.DefaultsUtils;

public class TranscoHandler implements Runnable {

	private static final int MAX_REQUESTS = 1000;
	
<<<<<<< HEAD
	private TranscoQueue queue;
	private int maxTransco;
	private DAO<ApplicationConfig> applicationDao = new DAO<ApplicationConfig>(ApplicationConfig.class);
	private DAO<TranscoRequest> requestDao = new DAO<TranscoRequest>(TranscoRequest.class);
	private Stack<SimpleEntry<String, Cancellable>> workers = new Stack<SimpleEntry<String, Cancellable>>();
	
	private boolean MQBlock = false;
	private boolean TQBlock = false;
	private boolean TTBlock = false;
=======
	private ProcessQueue queue;
	private DAO<TRequest> requestDao = new DAO<TRequest>(TRequest.class);
	private List<SimpleEntry<String, Cancellable>> workers = new ArrayList<SimpleEntry<String, Cancellable>>();
>>>>>>> MCASLive2
	
	private boolean run = true;
	
	public TranscoHandler() throws MCASException{
		queue = ProcessQueue.getInstance();
		queue.setMaxProcess(DefaultsUtils.MAX_PROCESS);
		if (DefaultsUtils.feedDefaultsNeeded()){
			DefaultsUtils.tConfigFeedDefaults();
		}
	}
	
	@Override
	public void run() {
		TRequest request = null;
		while(run){
			try {
<<<<<<< HEAD
				synchronized(queue){
					waitCondition();
				}
//				if (! MQBlock){
//					request = queue.get(State.M_QUEUED);
//					mediaHandle(request);
//				} 
				if (! TQBlock) {
					request = queue.get(Status.T_QUEUED);
					transcode(request);
				} 
//				if (! TTBlock) {
//					request = queue.get(State.T_TRANSCODED);
//					mediaHandle(request);
//				} 
			} catch (MCASException e) {
				if (request != null && ! request.getState().equals(Status.CANCELLED)){
=======
				request = queue.getAndProcess();
				transcode(request);
			} catch (MCASException e) {
				if (request != null && ! request.getStatus().equals(Status.CANCELLED)){
>>>>>>> MCASLive2
					request.setError();
				}
				if (queue.remove(request)){
						requestDao.save(request);
				}
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
<<<<<<< HEAD
	private void loadDefaults() throws MCASException {
		ApplicationConfig config = applicationDao.findByName(DefaultsUtils.DEFAULT);
		maxInMedia = config.getMaxInMediaH();
		maxOutMedia = config.getMaxOutMediaH();
		maxTransco = config.getMaxTransco();
	}
	
	public void loadConfig(Integer id) throws MCASException {
		ApplicationConfig config;
		try {
			config = applicationDao.findById(id);
			maxTransco = config.getMaxTransco();
		} catch (MCASException e) {
			loadDefaults();
			e.printStackTrace();
		}
	}
	
	public boolean cancelRequest(TranscoRequest request, boolean mayInterruptIfRunning) {
		synchronized(queue){
			request = queue.getRequest(request);
			if (request != null){
				if (request.getState().equals(Status.M_PROCESS) || 
					request.getState().equals(Status.T_PROCESS) ||
					request.getState().equals(Status.MOVING)) {
					try {
						if (! cancelWorker(request.getIdStr(), mayInterruptIfRunning)){
							MediaUtils.clean(request);
						}
					} catch (Exception e) {
=======
	public boolean cancelRequest(TRequest request, boolean mayInterruptIfRunning) {
		synchronized(queue){
			request = queue.getProcessObject(request);
			if (request != null && (request.isProcessing() || request.isWaiting())){
				try {
					if (request.isProcessing() && ! cancelWorker(request.getIdStr(), mayInterruptIfRunning)){
>>>>>>> MCASLive2
						return false;
					}
				} catch (Exception e) {
					return false;
				}
				request.setCancelled();
				if (queue.remove(request)) {
					requestDao.save(request);
				}
				return true;
			}
			return false;
		}
	}

	public boolean putRequest(TRequest request) throws MCASException {
		if (queue.size() < MAX_REQUESTS) {
			request.increaseStatus();
			queue.put(request);
			return true;
		} else {
			return false;
		}
	}
	
	private void increaseRequestState(TRequest request) throws MCASException {
		request.increaseStatus();
		queue.update(request);
	}
	
	public void stop(){
		run = false;
	}
	
<<<<<<< HEAD
	public TranscoRequest getRequest(UUID id) throws MCASException {
		return getRequest(TranscoRequest.getEqualRequest(id));
	}
	
	public String getState(TranscoRequest r) throws MCASException {
		Status state = queue.getState(r);
		if (state != null){
			return state.getName();
=======
	public TRequest getRequest(UUID id) throws MCASException {
		TRequest request = queue.getProcessObject(TRequest.getEqualRequest(id));
		if (request != null){
			return request;
>>>>>>> MCASLive2
		} else {
			request = requestDao.findById(id);
			if (request != null){
				return request;
			} else {
				throw new MCASException();
			}
		}
	}
	
	public Status getStatus(UUID id) throws MCASException {
		return getRequest(id).getStatus();
	}
	
//	private void mediaHandle(ProcessObject request) throws MCASException{
//		increaseRequestState(request);
//		MediaHandler mediaTh = new MediaHandler(queue, request);
//		(new Thread(mediaTh)).start();
//		addWorkerInStack(mediaTh, request.getIdStr());
//	}

	private void transcode(TRequest request) throws MCASException{
		increaseRequestState(request);
		Transcoder transTh = new Transcoder(queue, request);
		(new Thread(transTh)).start();
		addWorkerInStack(transTh, request.getIdStr());
	}
	
	private boolean cancelWorker(String id, boolean mayInterruptIfRunning) throws InterruptedException, ExecutionException{
		Iterator<SimpleEntry<String, Cancellable>> it = workers.iterator();
		while(it.hasNext()){
			SimpleEntry<String, Cancellable> worker = it.next();
			if (worker.getKey().equals(id)) {
				if (worker.getValue().cancel(mayInterruptIfRunning)) {
					it.remove();
					return true;
				} else {
					return false;
				}
			} 
		}
		return false;
	}
	
	private void addWorkerInStack(Cancellable thread, String id){
		Iterator<SimpleEntry<String, Cancellable>> it = workers.iterator();
		while(it.hasNext()){
			SimpleEntry<String, Cancellable> worker = it.next();
			if (worker.getKey().equals(id)) {
				worker.setValue(thread);
				cleanWorkers();
				return;
			} 
		}
		workers.add(new SimpleEntry<String, Cancellable>(id, thread));
		cleanWorkers();
	}
	
	private void cleanWorkers(){
		if (workers.size() > queue.getMaxProcess()){
			workers.remove(0);
		}
	}
<<<<<<< HEAD
	
	private void waitCondition() throws MCASException, InterruptedException{
		if(queue.isEmpty() || queue.count(Status.T_PROCESS) >= maxTransco){
			queue.wait();
			waitCondition();
		}
	}
	
	private boolean conditionMQ() throws MCASException {
		MQBlock = queue.isEmpty(Status.M_QUEUED) || queue.count(Status.M_PROCESS) >= maxInMedia || queue.count(Status.T_QUEUED) >= maxInMedia;
		return MQBlock;
	}
	
	private boolean conditionTQ() throws MCASException {
		TQBlock = queue.isEmpty(Status.T_QUEUED) || queue.count(Status.T_PROCESS) >= maxTransco || queue.count(Status.T_TRANSCODED) >= maxOutMedia;
		return TQBlock;
	}
	
	private boolean conditionTT() throws MCASException {
		TTBlock = queue.isEmpty(Status.T_TRANSCODED) || queue.count(Status.MOVING) >= maxOutMedia;
		return TTBlock;
	}
=======
>>>>>>> MCASLive2
}
